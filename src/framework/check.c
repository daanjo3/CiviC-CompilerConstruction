
/**
 * @file check.c
 *
 * Functions needed by check.
 * 
 * THIS FILE HAS BEEN GENERATED USING 
 * $Id: check.c.xsl 14618 2006-02-28 16:08:17Z                                jhb $.
 * DO NOT EDIT THIS FILE AS MIGHT BE CHANGED IN A LATER VERSION.
 *
 * ALL CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN!
 *
 */

/**
 * @defgroup check Check tree Functions
 *
 * Functions needed by check traversal.
 *
 * @{
 */


#include "check.h"
#include "globals.h"
#include "tree_basic.h"
#include "traverse.h"
#include "dbug.h"
#include "print.h"
#include "check_lib.h"
#include "free.h"
#include "str.h"
#include "memory.h"

/*****************************************************************************
 *
 * @fn node *CHKdoTreeCheck( node *syntax_tree)
 *
 ****************************************************************************/
node *
CHKdoTreeCheck (node * syntax_tree)
{
  DBUG_ENTER ("CHKdoTreeCheck");

  DBUG_PRINT ("CHK", ("Starting the check mechanism"));

  TRAVpush (TR_chk);
  syntax_tree = TRAVdo (syntax_tree, NULL);
  TRAVpop ();

  DBUG_PRINT ("CHK", ("Checkmechanism complete"));

  DBUG_RETURN (syntax_tree);
}

static bool
isDeclaration (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_fundefdec) ||
	      (NODE_TYPE (arg_node) == N_globaldec) ||
	      (NODE_TYPE (arg_node) == N_globaldef));
  return (res);
}

static bool
isExpr (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_binop) ||
	      (NODE_TYPE (arg_node) == N_bool) ||
	      (NODE_TYPE (arg_node) == N_cast) ||
	      (NODE_TYPE (arg_node) == N_float) ||
	      (NODE_TYPE (arg_node) == N_funcall) ||
	      (NODE_TYPE (arg_node) == N_monop) ||
	      (NODE_TYPE (arg_node) == N_num) ||
	      (NODE_TYPE (arg_node) == N_var));
  return (res);
}

static bool
isStmt (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_assign) ||
	      (NODE_TYPE (arg_node) == N_dowhile) ||
	      (NODE_TYPE (arg_node) == N_for) ||
	      (NODE_TYPE (arg_node) == N_funcall) ||
	      (NODE_TYPE (arg_node) == N_if) ||
	      (NODE_TYPE (arg_node) == N_return) ||
	      (NODE_TYPE (arg_node) == N_while));
  return (res);
}

void
isDummy ()
{
  isDeclaration (NULL);
  isExpr (NULL);
  isStmt (NULL);
}

/** <!--******************************************************************-->
 *
 * @fn CHKassign
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Assign node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKassign (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKassign");

/*
 * Son check: ASSIGN_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (ASSIGN_EXPR (arg_node), arg_node,
		   "mandatory son ASSIGN_EXPR is NULL");
      if (ASSIGN_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (ASSIGN_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ASSIGN_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (ASSIGN_EXPR (arg_node), arg_node,
		   "attribute ASSIGN_EXPR must be NULL");
    }

/*
 * Son check: ASSIGN_VAR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (ASSIGN_VAR (arg_node), arg_node,
		   "mandatory son ASSIGN_VAR is NULL");
      if (ASSIGN_VAR (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (ASSIGN_VAR (arg_node)) == N_var)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ASSIGN_VAR hasnt the right type."
					 " It should be: " "N_var");
	    }
	}
    }
  else
    {
      CHKnotExist (ASSIGN_VAR (arg_node), arg_node,
		   "attribute ASSIGN_VAR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (ASSIGN_EXPR (arg_node) != NULL)
    {
      ASSIGN_EXPR (arg_node) = TRAVdo (ASSIGN_EXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (ASSIGN_VAR (arg_node) != NULL)
    {
      ASSIGN_VAR (arg_node) = TRAVdo (ASSIGN_VAR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKbinop
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node BinOp node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKbinop (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKbinop");

/*
 * Son check: BINOP_LEFT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (BINOP_LEFT (arg_node), arg_node,
		   "mandatory son BINOP_LEFT is NULL");
      if (BINOP_LEFT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (BINOP_LEFT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "BINOP_LEFT hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (BINOP_LEFT (arg_node), arg_node,
		   "attribute BINOP_LEFT must be NULL");
    }

/*
 * Son check: BINOP_RIGHT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (BINOP_RIGHT (arg_node), arg_node,
		   "mandatory son BINOP_RIGHT is NULL");
      if (BINOP_RIGHT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (BINOP_RIGHT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "BINOP_RIGHT hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (BINOP_RIGHT (arg_node), arg_node,
		   "attribute BINOP_RIGHT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (BINOP_LEFT (arg_node) != NULL)
    {
      BINOP_LEFT (arg_node) = TRAVdo (BINOP_LEFT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (BINOP_RIGHT (arg_node) != NULL)
    {
      BINOP_RIGHT (arg_node) = TRAVdo (BINOP_RIGHT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKbool
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Bool node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKbool (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKbool");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKcast
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Cast node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKcast (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKcast");

/*
 * Son check: CAST_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (CAST_EXPR (arg_node), arg_node,
		   "mandatory son CAST_EXPR is NULL");
      if (CAST_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (CAST_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "CAST_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (CAST_EXPR (arg_node), arg_node,
		   "attribute CAST_EXPR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (CAST_EXPR (arg_node) != NULL)
    {
      CAST_EXPR (arg_node) = TRAVdo (CAST_EXPR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKdeclarations
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Declarations node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKdeclarations (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKdeclarations");

/*
 * Son check: DECLARATIONS_DECLARATION 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (DECLARATIONS_DECLARATION (arg_node), arg_node,
		   "mandatory son DECLARATIONS_DECLARATION is NULL");
      if (DECLARATIONS_DECLARATION (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (isDeclaration (DECLARATIONS_DECLARATION (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DECLARATIONS_DECLARATION hasnt the right type."
					 " It should be: "
					 "Nodeset: Declaration");
	    }
	}
    }
  else
    {
      CHKnotExist (DECLARATIONS_DECLARATION (arg_node), arg_node,
		   "attribute DECLARATIONS_DECLARATION must be NULL");
    }

/*
 * Son check: DECLARATIONS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (DECLARATIONS_NEXT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (DECLARATIONS_NEXT (arg_node)) ==
		   N_declarations)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DECLARATIONS_NEXT hasnt the right type."
					 " It should be: " "N_declarations");
	    }
	}
    }
  else
    {
      CHKnotExist (DECLARATIONS_NEXT (arg_node), arg_node,
		   "attribute DECLARATIONS_NEXT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (DECLARATIONS_DECLARATION (arg_node) != NULL)
    {
      DECLARATIONS_DECLARATION (arg_node) =
	TRAVdo (DECLARATIONS_DECLARATION (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (DECLARATIONS_NEXT (arg_node) != NULL)
    {
      DECLARATIONS_NEXT (arg_node) =
	TRAVdo (DECLARATIONS_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKdowhile
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node DoWhile node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKdowhile (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKdowhile");

/*
 * Son check: DOWHILE_BLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (DOWHILE_BLOCK (arg_node), arg_node,
		   "mandatory son DOWHILE_BLOCK is NULL");
      if (DOWHILE_BLOCK (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (DOWHILE_BLOCK (arg_node)) == N_statements)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DOWHILE_BLOCK hasnt the right type."
					 " It should be: " "N_statements");
	    }
	}
    }
  else
    {
      CHKnotExist (DOWHILE_BLOCK (arg_node), arg_node,
		   "attribute DOWHILE_BLOCK must be NULL");
    }

/*
 * Son check: DOWHILE_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (DOWHILE_EXPR (arg_node), arg_node,
		   "mandatory son DOWHILE_EXPR is NULL");
      if (DOWHILE_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (DOWHILE_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DOWHILE_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (DOWHILE_EXPR (arg_node), arg_node,
		   "attribute DOWHILE_EXPR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (DOWHILE_BLOCK (arg_node) != NULL)
    {
      DOWHILE_BLOCK (arg_node) = TRAVdo (DOWHILE_BLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (DOWHILE_EXPR (arg_node) != NULL)
    {
      DOWHILE_EXPR (arg_node) = TRAVdo (DOWHILE_EXPR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKerror
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Error node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKerror (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKerror");

/*
 * Son check: ERROR_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (ERROR_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (ERROR_NEXT (arg_node)) == N_error)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ERROR_NEXT hasnt the right type."
					 " It should be: " "N_error");
	    }
	}
    }
  else
    {
      CHKnotExist (ERROR_NEXT (arg_node), arg_node,
		   "attribute ERROR_NEXT must be NULL");
    }

/*
 * Attribute check: ERROR_MESSAGE
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (ERROR_MESSAGE (arg_node), arg_node,
			 "mandatory attribute ERROR_MESSAGE is NULL");
    }
  else
    {
      CHKnotExist (ERROR_MESSAGE (arg_node), arg_node,
		   "attribute ERROR_MESSAGE must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (ERROR_NEXT (arg_node) != NULL)
    {
      ERROR_NEXT (arg_node) = TRAVdo (ERROR_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKexprs
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Exprs node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKexprs (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKexprs");

/*
 * Son check: EXPRS_FIRST 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (EXPRS_FIRST (arg_node), arg_node,
		   "mandatory son EXPRS_FIRST is NULL");
      if (EXPRS_FIRST (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (EXPRS_FIRST (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "EXPRS_FIRST hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (EXPRS_FIRST (arg_node), arg_node,
		   "attribute EXPRS_FIRST must be NULL");
    }

/*
 * Son check: EXPRS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (EXPRS_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (EXPRS_NEXT (arg_node)) == N_exprs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "EXPRS_NEXT hasnt the right type."
					 " It should be: " "N_exprs");
	    }
	}
    }
  else
    {
      CHKnotExist (EXPRS_NEXT (arg_node), arg_node,
		   "attribute EXPRS_NEXT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (EXPRS_FIRST (arg_node) != NULL)
    {
      EXPRS_FIRST (arg_node) = TRAVdo (EXPRS_FIRST (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (EXPRS_NEXT (arg_node) != NULL)
    {
      EXPRS_NEXT (arg_node) = TRAVdo (EXPRS_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfloat
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Float node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfloat (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfloat");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfor
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node For node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfor (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfor");

/*
 * Son check: FOR_BLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FOR_BLOCK (arg_node), arg_node,
		   "mandatory son FOR_BLOCK is NULL");
      if (FOR_BLOCK (arg_node) != NULL)
	{
	  if (!
	      ((FALSE) || (NODE_TYPE (FOR_BLOCK (arg_node)) == N_statements)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_BLOCK hasnt the right type."
					 " It should be: " "N_statements");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_BLOCK (arg_node), arg_node,
		   "attribute FOR_BLOCK must be NULL");
    }

/*
 * Son check: FOR_EXPRINCR 
 */
  if ((FALSE) || (TRUE))
    {
      if (FOR_EXPRINCR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (FOR_EXPRINCR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_EXPRINCR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_EXPRINCR (arg_node), arg_node,
		   "attribute FOR_EXPRINCR must be NULL");
    }

/*
 * Son check: FOR_EXPRSTART 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FOR_EXPRSTART (arg_node), arg_node,
		   "mandatory son FOR_EXPRSTART is NULL");
      if (FOR_EXPRSTART (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (FOR_EXPRSTART (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_EXPRSTART hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_EXPRSTART (arg_node), arg_node,
		   "attribute FOR_EXPRSTART must be NULL");
    }

/*
 * Son check: FOR_EXPRSTOP 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FOR_EXPRSTOP (arg_node), arg_node,
		   "mandatory son FOR_EXPRSTOP is NULL");
      if (FOR_EXPRSTOP (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (FOR_EXPRSTOP (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_EXPRSTOP hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_EXPRSTOP (arg_node), arg_node,
		   "attribute FOR_EXPRSTOP must be NULL");
    }

/*
 * Son check: FOR_VAR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FOR_VAR (arg_node), arg_node,
		   "mandatory son FOR_VAR is NULL");
      if (FOR_VAR (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FOR_VAR (arg_node)) == N_var)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_VAR hasnt the right type."
					 " It should be: " "N_var");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_VAR (arg_node), arg_node,
		   "attribute FOR_VAR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_BLOCK (arg_node) != NULL)
    {
      FOR_BLOCK (arg_node) = TRAVdo (FOR_BLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_EXPRINCR (arg_node) != NULL)
    {
      FOR_EXPRINCR (arg_node) = TRAVdo (FOR_EXPRINCR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_EXPRSTART (arg_node) != NULL)
    {
      FOR_EXPRSTART (arg_node) = TRAVdo (FOR_EXPRSTART (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_EXPRSTOP (arg_node) != NULL)
    {
      FOR_EXPRSTOP (arg_node) = TRAVdo (FOR_EXPRSTOP (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_VAR (arg_node) != NULL)
    {
      FOR_VAR (arg_node) = TRAVdo (FOR_VAR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfunbody
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunBody node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfunbody (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfunbody");

/*
 * Son check: FUNBODY_LOCALFUNDEFS 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNBODY_LOCALFUNDEFS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNBODY_LOCALFUNDEFS (arg_node)) ==
		   N_localfundefs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNBODY_LOCALFUNDEFS hasnt the right type."
					 " It should be: " "N_localfundefs");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNBODY_LOCALFUNDEFS (arg_node), arg_node,
		   "attribute FUNBODY_LOCALFUNDEFS must be NULL");
    }

/*
 * Son check: FUNBODY_STATEMENTS 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNBODY_STATEMENTS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNBODY_STATEMENTS (arg_node)) ==
		   N_statements)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNBODY_STATEMENTS hasnt the right type."
					 " It should be: " "N_statements");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNBODY_STATEMENTS (arg_node), arg_node,
		   "attribute FUNBODY_STATEMENTS must be NULL");
    }

/*
 * Son check: FUNBODY_VARDEC 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNBODY_VARDEC (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNBODY_VARDEC (arg_node)) == N_vardec)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNBODY_VARDEC hasnt the right type."
					 " It should be: " "N_vardec");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNBODY_VARDEC (arg_node), arg_node,
		   "attribute FUNBODY_VARDEC must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNBODY_LOCALFUNDEFS (arg_node) != NULL)
    {
      FUNBODY_LOCALFUNDEFS (arg_node) =
	TRAVdo (FUNBODY_LOCALFUNDEFS (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNBODY_STATEMENTS (arg_node) != NULL)
    {
      FUNBODY_STATEMENTS (arg_node) =
	TRAVdo (FUNBODY_STATEMENTS (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNBODY_VARDEC (arg_node) != NULL)
    {
      FUNBODY_VARDEC (arg_node) =
	TRAVdo (FUNBODY_VARDEC (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfuncall
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunCall node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfuncall (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfuncall");

/*
 * Son check: FUNCALL_EXPRS 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNCALL_EXPRS (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FUNCALL_EXPRS (arg_node)) == N_exprs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNCALL_EXPRS hasnt the right type."
					 " It should be: " "N_exprs");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNCALL_EXPRS (arg_node), arg_node,
		   "attribute FUNCALL_EXPRS must be NULL");
    }

/*
 * Son check: FUNCALL_VAR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNCALL_VAR (arg_node), arg_node,
		   "mandatory son FUNCALL_VAR is NULL");
      if (FUNCALL_VAR (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FUNCALL_VAR (arg_node)) == N_var)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNCALL_VAR hasnt the right type."
					 " It should be: " "N_var");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNCALL_VAR (arg_node), arg_node,
		   "attribute FUNCALL_VAR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNCALL_EXPRS (arg_node) != NULL)
    {
      FUNCALL_EXPRS (arg_node) = TRAVdo (FUNCALL_EXPRS (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNCALL_VAR (arg_node) != NULL)
    {
      FUNCALL_VAR (arg_node) = TRAVdo (FUNCALL_VAR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfundefdec
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunDefDec node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfundefdec (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfundefdec");

/*
 * Son check: FUNDEFDEC_BODY 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNDEFDEC_BODY (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNDEFDEC_BODY (arg_node)) == N_funbody)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEFDEC_BODY hasnt the right type."
					 " It should be: " "N_funbody");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEFDEC_BODY (arg_node), arg_node,
		   "attribute FUNDEFDEC_BODY must be NULL");
    }

/*
 * Son check: FUNDEFDEC_PARAM 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNDEFDEC_PARAM (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNDEFDEC_PARAM (arg_node)) == N_param)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEFDEC_PARAM hasnt the right type."
					 " It should be: " "N_param");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEFDEC_PARAM (arg_node), arg_node,
		   "attribute FUNDEFDEC_PARAM must be NULL");
    }

/*
 * Son check: FUNDEFDEC_SYMBOLTABLE 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNDEFDEC_SYMBOLTABLE (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNDEFDEC_SYMBOLTABLE (arg_node)) ==
		   N_symboltable)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEFDEC_SYMBOLTABLE hasnt the right type."
					 " It should be: " "N_symboltable");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEFDEC_SYMBOLTABLE (arg_node), arg_node,
		   "attribute FUNDEFDEC_SYMBOLTABLE must be NULL");
    }

/*
 * Attribute check: FUNDEFDEC_ID
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (FUNDEFDEC_ID (arg_node), arg_node,
			 "mandatory attribute FUNDEFDEC_ID is NULL");
    }
  else
    {
      CHKnotExist (FUNDEFDEC_ID (arg_node), arg_node,
		   "attribute FUNDEFDEC_ID must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEFDEC_BODY (arg_node) != NULL)
    {
      FUNDEFDEC_BODY (arg_node) =
	TRAVdo (FUNDEFDEC_BODY (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEFDEC_PARAM (arg_node) != NULL)
    {
      FUNDEFDEC_PARAM (arg_node) =
	TRAVdo (FUNDEFDEC_PARAM (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEFDEC_SYMBOLTABLE (arg_node) != NULL)
    {
      FUNDEFDEC_SYMBOLTABLE (arg_node) =
	TRAVdo (FUNDEFDEC_SYMBOLTABLE (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKglobaldec
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node GlobalDec node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKglobaldec (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKglobaldec");

/*
 * Attribute check: GLOBALDEC_ID
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (GLOBALDEC_ID (arg_node), arg_node,
			 "mandatory attribute GLOBALDEC_ID is NULL");
    }
  else
    {
      CHKnotExist (GLOBALDEC_ID (arg_node), arg_node,
		   "attribute GLOBALDEC_ID must be NULL");
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKglobaldef
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node GlobalDef node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKglobaldef (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKglobaldef");

/*
 * Son check: GLOBALDEF_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      if (GLOBALDEF_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (GLOBALDEF_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBALDEF_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBALDEF_EXPR (arg_node), arg_node,
		   "attribute GLOBALDEF_EXPR must be NULL");
    }

/*
 * Attribute check: GLOBALDEF_ID
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (GLOBALDEF_ID (arg_node), arg_node,
			 "mandatory attribute GLOBALDEF_ID is NULL");
    }
  else
    {
      CHKnotExist (GLOBALDEF_ID (arg_node), arg_node,
		   "attribute GLOBALDEF_ID must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBALDEF_EXPR (arg_node) != NULL)
    {
      GLOBALDEF_EXPR (arg_node) =
	TRAVdo (GLOBALDEF_EXPR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKif
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node If node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKif (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKif");

/*
 * Son check: IF_BLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (IF_BLOCK (arg_node), arg_node,
		   "mandatory son IF_BLOCK is NULL");
      if (IF_BLOCK (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (IF_BLOCK (arg_node)) == N_statements)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IF_BLOCK hasnt the right type."
					 " It should be: " "N_statements");
	    }
	}
    }
  else
    {
      CHKnotExist (IF_BLOCK (arg_node), arg_node,
		   "attribute IF_BLOCK must be NULL");
    }

/*
 * Son check: IF_ELSEBLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      if (IF_ELSEBLOCK (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (IF_ELSEBLOCK (arg_node)) == N_statements)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IF_ELSEBLOCK hasnt the right type."
					 " It should be: " "N_statements");
	    }
	}
    }
  else
    {
      CHKnotExist (IF_ELSEBLOCK (arg_node), arg_node,
		   "attribute IF_ELSEBLOCK must be NULL");
    }

/*
 * Son check: IF_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (IF_EXPR (arg_node), arg_node,
		   "mandatory son IF_EXPR is NULL");
      if (IF_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (IF_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IF_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (IF_EXPR (arg_node), arg_node,
		   "attribute IF_EXPR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (IF_BLOCK (arg_node) != NULL)
    {
      IF_BLOCK (arg_node) = TRAVdo (IF_BLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (IF_ELSEBLOCK (arg_node) != NULL)
    {
      IF_ELSEBLOCK (arg_node) = TRAVdo (IF_ELSEBLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (IF_EXPR (arg_node) != NULL)
    {
      IF_EXPR (arg_node) = TRAVdo (IF_EXPR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKlocalfundefs
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node LocalFunDefs node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKlocalfundefs (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKlocalfundefs");

/*
 * Son check: LOCALFUNDEFS_FIRST 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (LOCALFUNDEFS_FIRST (arg_node), arg_node,
		   "mandatory son LOCALFUNDEFS_FIRST is NULL");
      if (LOCALFUNDEFS_FIRST (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (LOCALFUNDEFS_FIRST (arg_node)) == N_fundefdec)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "LOCALFUNDEFS_FIRST hasnt the right type."
					 " It should be: " "N_fundefdec");
	    }
	}
    }
  else
    {
      CHKnotExist (LOCALFUNDEFS_FIRST (arg_node), arg_node,
		   "attribute LOCALFUNDEFS_FIRST must be NULL");
    }

/*
 * Son check: LOCALFUNDEFS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (LOCALFUNDEFS_NEXT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (LOCALFUNDEFS_NEXT (arg_node)) ==
		   N_localfundefs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "LOCALFUNDEFS_NEXT hasnt the right type."
					 " It should be: " "N_localfundefs");
	    }
	}
    }
  else
    {
      CHKnotExist (LOCALFUNDEFS_NEXT (arg_node), arg_node,
		   "attribute LOCALFUNDEFS_NEXT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (LOCALFUNDEFS_FIRST (arg_node) != NULL)
    {
      LOCALFUNDEFS_FIRST (arg_node) =
	TRAVdo (LOCALFUNDEFS_FIRST (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (LOCALFUNDEFS_NEXT (arg_node) != NULL)
    {
      LOCALFUNDEFS_NEXT (arg_node) =
	TRAVdo (LOCALFUNDEFS_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKmonop
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node MonOp node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKmonop (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKmonop");

/*
 * Son check: MONOP_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (MONOP_EXPR (arg_node), arg_node,
		   "mandatory son MONOP_EXPR is NULL");
      if (MONOP_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (MONOP_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "MONOP_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (MONOP_EXPR (arg_node), arg_node,
		   "attribute MONOP_EXPR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (MONOP_EXPR (arg_node) != NULL)
    {
      MONOP_EXPR (arg_node) = TRAVdo (MONOP_EXPR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKnum
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Num node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKnum (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKnum");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKparam
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Param node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKparam (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKparam");

/*
 * Son check: PARAM_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (PARAM_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (PARAM_NEXT (arg_node)) == N_param)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PARAM_NEXT hasnt the right type."
					 " It should be: " "N_param");
	    }
	}
    }
  else
    {
      CHKnotExist (PARAM_NEXT (arg_node), arg_node,
		   "attribute PARAM_NEXT must be NULL");
    }

/*
 * Attribute check: PARAM_ID
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (PARAM_ID (arg_node), arg_node,
			 "mandatory attribute PARAM_ID is NULL");
    }
  else
    {
      CHKnotExist (PARAM_ID (arg_node), arg_node,
		   "attribute PARAM_ID must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (PARAM_NEXT (arg_node) != NULL)
    {
      PARAM_NEXT (arg_node) = TRAVdo (PARAM_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKprogram
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Program node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKprogram (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKprogram");

/*
 * Son check: PROGRAM_DECLARATIONS 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (PROGRAM_DECLARATIONS (arg_node), arg_node,
		   "mandatory son PROGRAM_DECLARATIONS is NULL");
      if (PROGRAM_DECLARATIONS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (PROGRAM_DECLARATIONS (arg_node)) ==
		   N_declarations)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PROGRAM_DECLARATIONS hasnt the right type."
					 " It should be: " "N_declarations");
	    }
	}
    }
  else
    {
      CHKnotExist (PROGRAM_DECLARATIONS (arg_node), arg_node,
		   "attribute PROGRAM_DECLARATIONS must be NULL");
    }

/*
 * Son check: PROGRAM_SYMBOLTABLE 
 */
  if ((FALSE) || (TRUE))
    {
      if (PROGRAM_SYMBOLTABLE (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (PROGRAM_SYMBOLTABLE (arg_node)) ==
		   N_symboltable)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PROGRAM_SYMBOLTABLE hasnt the right type."
					 " It should be: " "N_symboltable");
	    }
	}
    }
  else
    {
      CHKnotExist (PROGRAM_SYMBOLTABLE (arg_node), arg_node,
		   "attribute PROGRAM_SYMBOLTABLE must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (PROGRAM_DECLARATIONS (arg_node) != NULL)
    {
      PROGRAM_DECLARATIONS (arg_node) =
	TRAVdo (PROGRAM_DECLARATIONS (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (PROGRAM_SYMBOLTABLE (arg_node) != NULL)
    {
      PROGRAM_SYMBOLTABLE (arg_node) =
	TRAVdo (PROGRAM_SYMBOLTABLE (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKreturn
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Return node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKreturn (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKreturn");

/*
 * Son check: RETURN_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      if (RETURN_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (RETURN_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "RETURN_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (RETURN_EXPR (arg_node), arg_node,
		   "attribute RETURN_EXPR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (RETURN_EXPR (arg_node) != NULL)
    {
      RETURN_EXPR (arg_node) = TRAVdo (RETURN_EXPR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKstatements
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Statements node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKstatements (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKstatements");

/*
 * Son check: STATEMENTS_FIRST 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (STATEMENTS_FIRST (arg_node), arg_node,
		   "mandatory son STATEMENTS_FIRST is NULL");
      if (STATEMENTS_FIRST (arg_node) != NULL)
	{
	  if (!((FALSE) || (isStmt (STATEMENTS_FIRST (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "STATEMENTS_FIRST hasnt the right type."
					 " It should be: " "Nodeset: Stmt");
	    }
	}
    }
  else
    {
      CHKnotExist (STATEMENTS_FIRST (arg_node), arg_node,
		   "attribute STATEMENTS_FIRST must be NULL");
    }

/*
 * Son check: STATEMENTS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (STATEMENTS_NEXT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (STATEMENTS_NEXT (arg_node)) == N_statements)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "STATEMENTS_NEXT hasnt the right type."
					 " It should be: " "N_statements");
	    }
	}
    }
  else
    {
      CHKnotExist (STATEMENTS_NEXT (arg_node), arg_node,
		   "attribute STATEMENTS_NEXT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (STATEMENTS_FIRST (arg_node) != NULL)
    {
      STATEMENTS_FIRST (arg_node) =
	TRAVdo (STATEMENTS_FIRST (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (STATEMENTS_NEXT (arg_node) != NULL)
    {
      STATEMENTS_NEXT (arg_node) =
	TRAVdo (STATEMENTS_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKsymboltable
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node SymbolTable node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKsymboltable (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKsymboltable");

/*
 * Son check: SYMBOLTABLE_HEAD 
 */
  if ((FALSE) || (TRUE))
    {
      if (SYMBOLTABLE_HEAD (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (SYMBOLTABLE_HEAD (arg_node)) ==
		   N_symboltableentry)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "SYMBOLTABLE_HEAD hasnt the right type."
					 " It should be: "
					 "N_symboltableentry");
	    }
	}
    }
  else
    {
      CHKnotExist (SYMBOLTABLE_HEAD (arg_node), arg_node,
		   "attribute SYMBOLTABLE_HEAD must be NULL");
    }

/*
 * Attribute check: SYMBOLTABLE_PARENT
 */
  if ((FALSE) || (TRUE))
    {
    }
  else
    {
      CHKnotExist (SYMBOLTABLE_PARENT (arg_node), arg_node,
		   "attribute SYMBOLTABLE_PARENT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (SYMBOLTABLE_HEAD (arg_node) != NULL)
    {
      SYMBOLTABLE_HEAD (arg_node) =
	TRAVdo (SYMBOLTABLE_HEAD (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKsymboltableentry
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node SymbolTableEntry node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKsymboltableentry (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKsymboltableentry");

/*
 * Son check: SYMBOLTABLEENTRY_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (SYMBOLTABLEENTRY_NEXT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (SYMBOLTABLEENTRY_NEXT (arg_node)) ==
		   N_symboltableentry)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "SYMBOLTABLEENTRY_NEXT hasnt the right type."
					 " It should be: "
					 "N_symboltableentry");
	    }
	}
    }
  else
    {
      CHKnotExist (SYMBOLTABLEENTRY_NEXT (arg_node), arg_node,
		   "attribute SYMBOLTABLEENTRY_NEXT must be NULL");
    }

/*
 * Attribute check: SYMBOLTABLEENTRY_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (SYMBOLTABLEENTRY_NAME (arg_node), arg_node,
			 "mandatory attribute SYMBOLTABLEENTRY_NAME is NULL");
    }
  else
    {
      CHKnotExist (SYMBOLTABLEENTRY_NAME (arg_node), arg_node,
		   "attribute SYMBOLTABLEENTRY_NAME must be NULL");
    }

/*
 * Attribute check: SYMBOLTABLEENTRY_PARAMS
 */
  if ((FALSE) || (TRUE))
    {
    }
  else
    {
      CHKnotExist (SYMBOLTABLEENTRY_PARAMS (arg_node), arg_node,
		   "attribute SYMBOLTABLEENTRY_PARAMS must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (SYMBOLTABLEENTRY_NEXT (arg_node) != NULL)
    {
      SYMBOLTABLEENTRY_NEXT (arg_node) =
	TRAVdo (SYMBOLTABLEENTRY_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKvar
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Var node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKvar (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKvar");

/*
 * Attribute check: VAR_LINK
 */
  if ((FALSE) || (TRUE))
    {
    }
  else
    {
      CHKnotExist (VAR_LINK (arg_node), arg_node,
		   "attribute VAR_LINK must be NULL");
    }

/*
 * Attribute check: VAR_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (VAR_NAME (arg_node), arg_node,
			 "mandatory attribute VAR_NAME is NULL");
    }
  else
    {
      CHKnotExist (VAR_NAME (arg_node), arg_node,
		   "attribute VAR_NAME must be NULL");
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKvardec
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node VarDec node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKvardec (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKvardec");

/*
 * Son check: VARDEC_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      if (VARDEC_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (VARDEC_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "VARDEC_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (VARDEC_EXPR (arg_node), arg_node,
		   "attribute VARDEC_EXPR must be NULL");
    }

/*
 * Son check: VARDEC_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (VARDEC_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (VARDEC_NEXT (arg_node)) == N_vardec)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "VARDEC_NEXT hasnt the right type."
					 " It should be: " "N_vardec");
	    }
	}
    }
  else
    {
      CHKnotExist (VARDEC_NEXT (arg_node), arg_node,
		   "attribute VARDEC_NEXT must be NULL");
    }

/*
 * Attribute check: VARDEC_ID
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (VARDEC_ID (arg_node), arg_node,
			 "mandatory attribute VARDEC_ID is NULL");
    }
  else
    {
      CHKnotExist (VARDEC_ID (arg_node), arg_node,
		   "attribute VARDEC_ID must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (VARDEC_EXPR (arg_node) != NULL)
    {
      VARDEC_EXPR (arg_node) = TRAVdo (VARDEC_EXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (VARDEC_NEXT (arg_node) != NULL)
    {
      VARDEC_NEXT (arg_node) = TRAVdo (VARDEC_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKwhile
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node While node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKwhile (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKwhile");

/*
 * Son check: WHILE_BLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (WHILE_BLOCK (arg_node), arg_node,
		   "mandatory son WHILE_BLOCK is NULL");
      if (WHILE_BLOCK (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (WHILE_BLOCK (arg_node)) == N_statements)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "WHILE_BLOCK hasnt the right type."
					 " It should be: " "N_statements");
	    }
	}
    }
  else
    {
      CHKnotExist (WHILE_BLOCK (arg_node), arg_node,
		   "attribute WHILE_BLOCK must be NULL");
    }

/*
 * Son check: WHILE_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (WHILE_EXPR (arg_node), arg_node,
		   "mandatory son WHILE_EXPR is NULL");
      if (WHILE_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (WHILE_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "WHILE_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (WHILE_EXPR (arg_node), arg_node,
		   "attribute WHILE_EXPR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (WHILE_BLOCK (arg_node) != NULL)
    {
      WHILE_BLOCK (arg_node) = TRAVdo (WHILE_BLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (WHILE_EXPR (arg_node) != NULL)
    {
      WHILE_EXPR (arg_node) = TRAVdo (WHILE_EXPR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

typedef enum
{ CHK_binop_op,
  CHK_bool_value,
  CHK_cast_casttype,
  CHK_error_message,
  CHK_float_value,
  CHK_fundefdec_export,
  CHK_globaldec_type,
  CHK_globaldef_type,
  CHK_monop_op,
  CHK_num_value,
  CHK_param_type,
  CHK_symboltable_parent,
  CHK_symboltableentry_name,
  CHK_var_name,
  CHK_vardec_type,
} attr_list;
