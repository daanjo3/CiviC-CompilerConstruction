
/**
 * @file check.c
 *
 * Functions needed by check.
 * 
 * THIS FILE HAS BEEN GENERATED USING 
 * $Id: check.c.xsl 14618 2006-02-28 16:08:17Z                                jhb $.
 * DO NOT EDIT THIS FILE AS MIGHT BE CHANGED IN A LATER VERSION.
 *
 * ALL CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN!
 *
 */

/**
 * @defgroup check Check tree Functions
 *
 * Functions needed by check traversal.
 *
 * @{
 */


#include "check.h"
#include "globals.h"
#include "tree_basic.h"
#include "traverse.h"
#include "dbug.h"
#include "print.h"
#include "check_lib.h"
#include "free.h"
#include "str.h"
#include "memory.h"

/*****************************************************************************
 *
 * @fn node *CHKdoTreeCheck( node *syntax_tree)
 *
 ****************************************************************************/
node *
CHKdoTreeCheck (node * syntax_tree)
{
  DBUG_ENTER ("CHKdoTreeCheck");

  DBUG_PRINT ("CHK", ("Starting the check mechanism"));

  TRAVpush (TR_chk);
  syntax_tree = TRAVdo (syntax_tree, NULL);
  TRAVpop ();

  DBUG_PRINT ("CHK", ("Checkmechanism complete"));

  DBUG_RETURN (syntax_tree);
}

static bool
isConst (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_bool) ||
	      (NODE_TYPE (arg_node) == N_float) ||
	      (NODE_TYPE (arg_node) == N_num));
  return (res);
}

static bool
isDeclaration (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_fundec) ||
	      (NODE_TYPE (arg_node) == N_fundef) ||
	      (NODE_TYPE (arg_node) == N_globaldec) ||
	      (NODE_TYPE (arg_node) == N_globaldef));
  return (res);
}

static bool
isExpr (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_binop) ||
	      (NODE_TYPE (arg_node) == N_cast) ||
	      (NODE_TYPE (arg_node) == N_const) ||
	      (NODE_TYPE (arg_node) == N_funcall) ||
	      (NODE_TYPE (arg_node) == N_id) ||
	      (NODE_TYPE (arg_node) == N_monop));
  return (res);
}

static bool
isStmt (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_assign) ||
	      (NODE_TYPE (arg_node) == N_dowhile) ||
	      (NODE_TYPE (arg_node) == N_dowhile) ||
	      (NODE_TYPE (arg_node) == N_for) ||
	      (NODE_TYPE (arg_node) == N_if) ||
	      (NODE_TYPE (arg_node) == N_return) ||
	      (NODE_TYPE (arg_node) == N_while));
  return (res);
}

void
isDummy ()
{
  isConst (NULL);
  isDeclaration (NULL);
  isExpr (NULL);
  isStmt (NULL);
}

/** <!--******************************************************************-->
 *
 * @fn CHKassign
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Assign node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKassign (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKassign");

/*
 * Son check: ASSIGN_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (ASSIGN_EXPR (arg_node), arg_node,
		   "mandatory son ASSIGN_EXPR is NULL");
      if (ASSIGN_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (ASSIGN_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ASSIGN_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (ASSIGN_EXPR (arg_node), arg_node,
		   "attribute ASSIGN_EXPR must be NULL");
    }

/*
 * Son check: ASSIGN_ID 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (ASSIGN_ID (arg_node), arg_node,
		   "mandatory son ASSIGN_ID is NULL");
      if (ASSIGN_ID (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (ASSIGN_ID (arg_node)) == N_id)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ASSIGN_ID hasnt the right type."
					 " It should be: " "N_id");
	    }
	}
    }
  else
    {
      CHKnotExist (ASSIGN_ID (arg_node), arg_node,
		   "attribute ASSIGN_ID must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (ASSIGN_EXPR (arg_node) != NULL)
    {
      ASSIGN_EXPR (arg_node) = TRAVdo (ASSIGN_EXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (ASSIGN_ID (arg_node) != NULL)
    {
      ASSIGN_ID (arg_node) = TRAVdo (ASSIGN_ID (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKbinop
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node BinOp node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKbinop (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKbinop");

/*
 * Son check: BINOP_LEFT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (BINOP_LEFT (arg_node), arg_node,
		   "mandatory son BINOP_LEFT is NULL");
      if (BINOP_LEFT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (BINOP_LEFT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "BINOP_LEFT hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (BINOP_LEFT (arg_node), arg_node,
		   "attribute BINOP_LEFT must be NULL");
    }

/*
 * Son check: BINOP_RIGHT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (BINOP_RIGHT (arg_node), arg_node,
		   "mandatory son BINOP_RIGHT is NULL");
      if (BINOP_RIGHT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (BINOP_RIGHT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "BINOP_RIGHT hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (BINOP_RIGHT (arg_node), arg_node,
		   "attribute BINOP_RIGHT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (BINOP_LEFT (arg_node) != NULL)
    {
      BINOP_LEFT (arg_node) = TRAVdo (BINOP_LEFT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (BINOP_RIGHT (arg_node) != NULL)
    {
      BINOP_RIGHT (arg_node) = TRAVdo (BINOP_RIGHT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKbool
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Bool node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKbool (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKbool");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKcast
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Cast node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKcast (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKcast");

/*
 * Son check: CAST_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (CAST_EXPR (arg_node), arg_node,
		   "mandatory son CAST_EXPR is NULL");
      if (CAST_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (CAST_EXPR (arg_node)) == N_expr)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "CAST_EXPR hasnt the right type."
					 " It should be: " "N_expr");
	    }
	}
    }
  else
    {
      CHKnotExist (CAST_EXPR (arg_node), arg_node,
		   "attribute CAST_EXPR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (CAST_EXPR (arg_node) != NULL)
    {
      CAST_EXPR (arg_node) = TRAVdo (CAST_EXPR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKdeclarations
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Declarations node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKdeclarations (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKdeclarations");

/*
 * Son check: DECLARATIONS_DECLARATION 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (DECLARATIONS_DECLARATION (arg_node), arg_node,
		   "mandatory son DECLARATIONS_DECLARATION is NULL");
      if (DECLARATIONS_DECLARATION (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (isDeclaration (DECLARATIONS_DECLARATION (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DECLARATIONS_DECLARATION hasnt the right type."
					 " It should be: "
					 "Nodeset: Declaration");
	    }
	}
    }
  else
    {
      CHKnotExist (DECLARATIONS_DECLARATION (arg_node), arg_node,
		   "attribute DECLARATIONS_DECLARATION must be NULL");
    }

/*
 * Son check: DECLARATIONS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (DECLARATIONS_NEXT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (DECLARATIONS_NEXT (arg_node)) ==
		   N_declarations)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DECLARATIONS_NEXT hasnt the right type."
					 " It should be: " "N_declarations");
	    }
	}
    }
  else
    {
      CHKnotExist (DECLARATIONS_NEXT (arg_node), arg_node,
		   "attribute DECLARATIONS_NEXT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (DECLARATIONS_DECLARATION (arg_node) != NULL)
    {
      DECLARATIONS_DECLARATION (arg_node) =
	TRAVdo (DECLARATIONS_DECLARATION (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (DECLARATIONS_NEXT (arg_node) != NULL)
    {
      DECLARATIONS_NEXT (arg_node) =
	TRAVdo (DECLARATIONS_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKdowhile
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node DoWhile node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKdowhile (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKdowhile");

/*
 * Son check: DOWHILE_BLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (DOWHILE_BLOCK (arg_node), arg_node,
		   "mandatory son DOWHILE_BLOCK is NULL");
      if (DOWHILE_BLOCK (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (DOWHILE_BLOCK (arg_node)) == N_stmts)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DOWHILE_BLOCK hasnt the right type."
					 " It should be: " "N_stmts");
	    }
	}
    }
  else
    {
      CHKnotExist (DOWHILE_BLOCK (arg_node), arg_node,
		   "attribute DOWHILE_BLOCK must be NULL");
    }

/*
 * Son check: DOWHILE_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (DOWHILE_EXPR (arg_node), arg_node,
		   "mandatory son DOWHILE_EXPR is NULL");
      if (DOWHILE_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (DOWHILE_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DOWHILE_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (DOWHILE_EXPR (arg_node), arg_node,
		   "attribute DOWHILE_EXPR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (DOWHILE_BLOCK (arg_node) != NULL)
    {
      DOWHILE_BLOCK (arg_node) = TRAVdo (DOWHILE_BLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (DOWHILE_EXPR (arg_node) != NULL)
    {
      DOWHILE_EXPR (arg_node) = TRAVdo (DOWHILE_EXPR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKerror
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Error node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKerror (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKerror");

/*
 * Son check: ERROR_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (ERROR_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (ERROR_NEXT (arg_node)) == N_error)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ERROR_NEXT hasnt the right type."
					 " It should be: " "N_error");
	    }
	}
    }
  else
    {
      CHKnotExist (ERROR_NEXT (arg_node), arg_node,
		   "attribute ERROR_NEXT must be NULL");
    }

/*
 * Attribute check: ERROR_MESSAGE
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (ERROR_MESSAGE (arg_node), arg_node,
			 "mandatory attribute ERROR_MESSAGE is NULL");
    }
  else
    {
      CHKnotExist (ERROR_MESSAGE (arg_node), arg_node,
		   "attribute ERROR_MESSAGE must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (ERROR_NEXT (arg_node) != NULL)
    {
      ERROR_NEXT (arg_node) = TRAVdo (ERROR_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKexprs
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Exprs node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKexprs (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKexprs");

/*
 * Son check: EXPRS_FIRST 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (EXPRS_FIRST (arg_node), arg_node,
		   "mandatory son EXPRS_FIRST is NULL");
      if (EXPRS_FIRST (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (EXPRS_FIRST (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "EXPRS_FIRST hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (EXPRS_FIRST (arg_node), arg_node,
		   "attribute EXPRS_FIRST must be NULL");
    }

/*
 * Son check: EXPRS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (EXPRS_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (EXPRS_NEXT (arg_node)) == N_exprs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "EXPRS_NEXT hasnt the right type."
					 " It should be: " "N_exprs");
	    }
	}
    }
  else
    {
      CHKnotExist (EXPRS_NEXT (arg_node), arg_node,
		   "attribute EXPRS_NEXT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (EXPRS_FIRST (arg_node) != NULL)
    {
      EXPRS_FIRST (arg_node) = TRAVdo (EXPRS_FIRST (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (EXPRS_NEXT (arg_node) != NULL)
    {
      EXPRS_NEXT (arg_node) = TRAVdo (EXPRS_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfloat
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Float node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfloat (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfloat");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfor
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node For node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfor (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfor");

/*
 * Son check: FOR_ASSIGN 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FOR_ASSIGN (arg_node), arg_node,
		   "mandatory son FOR_ASSIGN is NULL");
      if (FOR_ASSIGN (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FOR_ASSIGN (arg_node)) == N_assign)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_ASSIGN hasnt the right type."
					 " It should be: " "N_assign");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_ASSIGN (arg_node), arg_node,
		   "attribute FOR_ASSIGN must be NULL");
    }

/*
 * Son check: FOR_BLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FOR_BLOCK (arg_node), arg_node,
		   "mandatory son FOR_BLOCK is NULL");
      if (FOR_BLOCK (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FOR_BLOCK (arg_node)) == N_stmts)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_BLOCK hasnt the right type."
					 " It should be: " "N_stmts");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_BLOCK (arg_node), arg_node,
		   "attribute FOR_BLOCK must be NULL");
    }

/*
 * Son check: FOR_EXPRINCR 
 */
  if ((FALSE) || (TRUE))
    {
      if (FOR_EXPRINCR (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FOR_EXPRINCR (arg_node)) == N_expr)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_EXPRINCR hasnt the right type."
					 " It should be: " "N_expr");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_EXPRINCR (arg_node), arg_node,
		   "attribute FOR_EXPRINCR must be NULL");
    }

/*
 * Son check: FOR_EXPRSTOP 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FOR_EXPRSTOP (arg_node), arg_node,
		   "mandatory son FOR_EXPRSTOP is NULL");
      if (FOR_EXPRSTOP (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FOR_EXPRSTOP (arg_node)) == N_expr)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_EXPRSTOP hasnt the right type."
					 " It should be: " "N_expr");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_EXPRSTOP (arg_node), arg_node,
		   "attribute FOR_EXPRSTOP must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_ASSIGN (arg_node) != NULL)
    {
      FOR_ASSIGN (arg_node) = TRAVdo (FOR_ASSIGN (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_BLOCK (arg_node) != NULL)
    {
      FOR_BLOCK (arg_node) = TRAVdo (FOR_BLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_EXPRINCR (arg_node) != NULL)
    {
      FOR_EXPRINCR (arg_node) = TRAVdo (FOR_EXPRINCR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_EXPRSTOP (arg_node) != NULL)
    {
      FOR_EXPRSTOP (arg_node) = TRAVdo (FOR_EXPRSTOP (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfunbody
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunBody node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfunbody (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfunbody");

/*
 * Son check: FUNBODY_LOCALFUNDEFS 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNBODY_LOCALFUNDEFS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNBODY_LOCALFUNDEFS (arg_node)) ==
		   N_localfundefs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNBODY_LOCALFUNDEFS hasnt the right type."
					 " It should be: " "N_localfundefs");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNBODY_LOCALFUNDEFS (arg_node), arg_node,
		   "attribute FUNBODY_LOCALFUNDEFS must be NULL");
    }

/*
 * Son check: FUNBODY_STATEMENTS 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNBODY_STATEMENTS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNBODY_STATEMENTS (arg_node)) == N_stmts)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNBODY_STATEMENTS hasnt the right type."
					 " It should be: " "N_stmts");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNBODY_STATEMENTS (arg_node), arg_node,
		   "attribute FUNBODY_STATEMENTS must be NULL");
    }

/*
 * Son check: FUNBODY_VARDECS 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNBODY_VARDECS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNBODY_VARDECS (arg_node)) == N_vardecs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNBODY_VARDECS hasnt the right type."
					 " It should be: " "N_vardecs");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNBODY_VARDECS (arg_node), arg_node,
		   "attribute FUNBODY_VARDECS must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNBODY_LOCALFUNDEFS (arg_node) != NULL)
    {
      FUNBODY_LOCALFUNDEFS (arg_node) =
	TRAVdo (FUNBODY_LOCALFUNDEFS (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNBODY_STATEMENTS (arg_node) != NULL)
    {
      FUNBODY_STATEMENTS (arg_node) =
	TRAVdo (FUNBODY_STATEMENTS (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNBODY_VARDECS (arg_node) != NULL)
    {
      FUNBODY_VARDECS (arg_node) =
	TRAVdo (FUNBODY_VARDECS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfuncall
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunCall node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfuncall (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfuncall");

/*
 * Son check: FUNCALL_EXPRS 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNCALL_EXPRS (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FUNCALL_EXPRS (arg_node)) == N_exprs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNCALL_EXPRS hasnt the right type."
					 " It should be: " "N_exprs");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNCALL_EXPRS (arg_node), arg_node,
		   "attribute FUNCALL_EXPRS must be NULL");
    }

/*
 * Son check: FUNCALL_ID 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNCALL_ID (arg_node), arg_node,
		   "mandatory son FUNCALL_ID is NULL");
      if (FUNCALL_ID (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FUNCALL_ID (arg_node)) == N_id)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNCALL_ID hasnt the right type."
					 " It should be: " "N_id");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNCALL_ID (arg_node), arg_node,
		   "attribute FUNCALL_ID must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNCALL_EXPRS (arg_node) != NULL)
    {
      FUNCALL_EXPRS (arg_node) = TRAVdo (FUNCALL_EXPRS (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNCALL_ID (arg_node) != NULL)
    {
      FUNCALL_ID (arg_node) = TRAVdo (FUNCALL_ID (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfundec
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunDec node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfundec (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfundec");

/*
 * Son check: FUNDEC_FUNHEADER 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNDEC_FUNHEADER (arg_node), arg_node,
		   "mandatory son FUNDEC_FUNHEADER is NULL");
      if (FUNDEC_FUNHEADER (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNDEC_FUNHEADER (arg_node)) == N_funheader)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEC_FUNHEADER hasnt the right type."
					 " It should be: " "N_funheader");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEC_FUNHEADER (arg_node), arg_node,
		   "attribute FUNDEC_FUNHEADER must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEC_FUNHEADER (arg_node) != NULL)
    {
      FUNDEC_FUNHEADER (arg_node) =
	TRAVdo (FUNDEC_FUNHEADER (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfundef
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunDef node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfundef (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfundef");

/*
 * Son check: FUNDEF_BODY 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNDEF_BODY (arg_node), arg_node,
		   "mandatory son FUNDEF_BODY is NULL");
      if (FUNDEF_BODY (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FUNDEF_BODY (arg_node)) == N_funbody)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEF_BODY hasnt the right type."
					 " It should be: " "N_funbody");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEF_BODY (arg_node), arg_node,
		   "attribute FUNDEF_BODY must be NULL");
    }

/*
 * Son check: FUNDEF_HEADER 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNDEF_HEADER (arg_node), arg_node,
		   "mandatory son FUNDEF_HEADER is NULL");
      if (FUNDEF_HEADER (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNDEF_HEADER (arg_node)) == N_funheader)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEF_HEADER hasnt the right type."
					 " It should be: " "N_funheader");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEF_HEADER (arg_node), arg_node,
		   "attribute FUNDEF_HEADER must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEF_BODY (arg_node) != NULL)
    {
      FUNDEF_BODY (arg_node) = TRAVdo (FUNDEF_BODY (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEF_HEADER (arg_node) != NULL)
    {
      FUNDEF_HEADER (arg_node) = TRAVdo (FUNDEF_HEADER (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfunheader
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunHeader node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfunheader (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfunheader");

/*
 * Son check: FUNHEADER_ID 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNHEADER_ID (arg_node), arg_node,
		   "mandatory son FUNHEADER_ID is NULL");
      if (FUNHEADER_ID (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FUNHEADER_ID (arg_node)) == N_id)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNHEADER_ID hasnt the right type."
					 " It should be: " "N_id");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNHEADER_ID (arg_node), arg_node,
		   "attribute FUNHEADER_ID must be NULL");
    }

/*
 * Son check: FUNHEADER_PARAMS 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNHEADER_PARAMS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNHEADER_PARAMS (arg_node)) == N_params)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNHEADER_PARAMS hasnt the right type."
					 " It should be: " "N_params");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNHEADER_PARAMS (arg_node), arg_node,
		   "attribute FUNHEADER_PARAMS must be NULL");
    }

/*
 * Attribute check: FUNHEADER_RETTYPE
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (FUNHEADER_RETTYPE (arg_node), arg_node,
			 "mandatory attribute FUNHEADER_RETTYPE is NULL");
    }
  else
    {
      CHKnotExist (FUNHEADER_RETTYPE (arg_node), arg_node,
		   "attribute FUNHEADER_RETTYPE must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNHEADER_ID (arg_node) != NULL)
    {
      FUNHEADER_ID (arg_node) = TRAVdo (FUNHEADER_ID (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNHEADER_PARAMS (arg_node) != NULL)
    {
      FUNHEADER_PARAMS (arg_node) =
	TRAVdo (FUNHEADER_PARAMS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKglobaldec
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node GlobalDec node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKglobaldec (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKglobaldec");

/*
 * Son check: GLOBALDEC_ID 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (GLOBALDEC_ID (arg_node), arg_node,
		   "mandatory son GLOBALDEC_ID is NULL");
      if (GLOBALDEC_ID (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (GLOBALDEC_ID (arg_node)) == N_id)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBALDEC_ID hasnt the right type."
					 " It should be: " "N_id");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBALDEC_ID (arg_node), arg_node,
		   "attribute GLOBALDEC_ID must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBALDEC_ID (arg_node) != NULL)
    {
      GLOBALDEC_ID (arg_node) = TRAVdo (GLOBALDEC_ID (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKglobaldef
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node GlobalDef node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKglobaldef (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKglobaldef");

/*
 * Son check: GLOBALDEF_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      if (GLOBALDEF_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (GLOBALDEF_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBALDEF_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBALDEF_EXPR (arg_node), arg_node,
		   "attribute GLOBALDEF_EXPR must be NULL");
    }

/*
 * Son check: GLOBALDEF_ID 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (GLOBALDEF_ID (arg_node), arg_node,
		   "mandatory son GLOBALDEF_ID is NULL");
      if (GLOBALDEF_ID (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (GLOBALDEF_ID (arg_node)) == N_id)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBALDEF_ID hasnt the right type."
					 " It should be: " "N_id");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBALDEF_ID (arg_node), arg_node,
		   "attribute GLOBALDEF_ID must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBALDEF_EXPR (arg_node) != NULL)
    {
      GLOBALDEF_EXPR (arg_node) =
	TRAVdo (GLOBALDEF_EXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBALDEF_ID (arg_node) != NULL)
    {
      GLOBALDEF_ID (arg_node) = TRAVdo (GLOBALDEF_ID (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKid
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Id node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKid (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKid");

/*
 * Attribute check: ID_NAME
 */
  {
    CHKnotExist (ID_NAME (arg_node), arg_node,
		 "attribute ID_NAME must be NULL");
  }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKif
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node If node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKif (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKif");

/*
 * Son check: IF_BLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (IF_BLOCK (arg_node), arg_node,
		   "mandatory son IF_BLOCK is NULL");
      if (IF_BLOCK (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (IF_BLOCK (arg_node)) == N_stmts)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IF_BLOCK hasnt the right type."
					 " It should be: " "N_stmts");
	    }
	}
    }
  else
    {
      CHKnotExist (IF_BLOCK (arg_node), arg_node,
		   "attribute IF_BLOCK must be NULL");
    }

/*
 * Son check: IF_ELSEBLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      if (IF_ELSEBLOCK (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (IF_ELSEBLOCK (arg_node)) == N_stmts)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IF_ELSEBLOCK hasnt the right type."
					 " It should be: " "N_stmts");
	    }
	}
    }
  else
    {
      CHKnotExist (IF_ELSEBLOCK (arg_node), arg_node,
		   "attribute IF_ELSEBLOCK must be NULL");
    }

/*
 * Son check: IF_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (IF_EXPR (arg_node), arg_node,
		   "mandatory son IF_EXPR is NULL");
      if (IF_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (IF_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IF_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (IF_EXPR (arg_node), arg_node,
		   "attribute IF_EXPR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (IF_BLOCK (arg_node) != NULL)
    {
      IF_BLOCK (arg_node) = TRAVdo (IF_BLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (IF_ELSEBLOCK (arg_node) != NULL)
    {
      IF_ELSEBLOCK (arg_node) = TRAVdo (IF_ELSEBLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (IF_EXPR (arg_node) != NULL)
    {
      IF_EXPR (arg_node) = TRAVdo (IF_EXPR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKlocalfundef
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node LocalFunDef node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKlocalfundef (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKlocalfundef");

/*
 * Son check: LOCALFUNDEF_BODY 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (LOCALFUNDEF_BODY (arg_node), arg_node,
		   "mandatory son LOCALFUNDEF_BODY is NULL");
      if (LOCALFUNDEF_BODY (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (LOCALFUNDEF_BODY (arg_node)) == N_funbody)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "LOCALFUNDEF_BODY hasnt the right type."
					 " It should be: " "N_funbody");
	    }
	}
    }
  else
    {
      CHKnotExist (LOCALFUNDEF_BODY (arg_node), arg_node,
		   "attribute LOCALFUNDEF_BODY must be NULL");
    }

/*
 * Son check: LOCALFUNDEF_HEADER 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (LOCALFUNDEF_HEADER (arg_node), arg_node,
		   "mandatory son LOCALFUNDEF_HEADER is NULL");
      if (LOCALFUNDEF_HEADER (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (LOCALFUNDEF_HEADER (arg_node)) == N_funheader)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "LOCALFUNDEF_HEADER hasnt the right type."
					 " It should be: " "N_funheader");
	    }
	}
    }
  else
    {
      CHKnotExist (LOCALFUNDEF_HEADER (arg_node), arg_node,
		   "attribute LOCALFUNDEF_HEADER must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (LOCALFUNDEF_BODY (arg_node) != NULL)
    {
      LOCALFUNDEF_BODY (arg_node) =
	TRAVdo (LOCALFUNDEF_BODY (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (LOCALFUNDEF_HEADER (arg_node) != NULL)
    {
      LOCALFUNDEF_HEADER (arg_node) =
	TRAVdo (LOCALFUNDEF_HEADER (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKlocalfundefs
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node LocalFunDefs node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKlocalfundefs (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKlocalfundefs");

/*
 * Son check: LOCALFUNDEFS_FIRST 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (LOCALFUNDEFS_FIRST (arg_node), arg_node,
		   "mandatory son LOCALFUNDEFS_FIRST is NULL");
      if (LOCALFUNDEFS_FIRST (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (LOCALFUNDEFS_FIRST (arg_node)) ==
		   N_localfundef)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "LOCALFUNDEFS_FIRST hasnt the right type."
					 " It should be: " "N_localfundef");
	    }
	}
    }
  else
    {
      CHKnotExist (LOCALFUNDEFS_FIRST (arg_node), arg_node,
		   "attribute LOCALFUNDEFS_FIRST must be NULL");
    }

/*
 * Son check: LOCALFUNDEFS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (LOCALFUNDEFS_NEXT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (LOCALFUNDEFS_NEXT (arg_node)) ==
		   N_localfundefs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "LOCALFUNDEFS_NEXT hasnt the right type."
					 " It should be: " "N_localfundefs");
	    }
	}
    }
  else
    {
      CHKnotExist (LOCALFUNDEFS_NEXT (arg_node), arg_node,
		   "attribute LOCALFUNDEFS_NEXT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (LOCALFUNDEFS_FIRST (arg_node) != NULL)
    {
      LOCALFUNDEFS_FIRST (arg_node) =
	TRAVdo (LOCALFUNDEFS_FIRST (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (LOCALFUNDEFS_NEXT (arg_node) != NULL)
    {
      LOCALFUNDEFS_NEXT (arg_node) =
	TRAVdo (LOCALFUNDEFS_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKmonop
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node MonOp node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKmonop (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKmonop");

/*
 * Son check: MONOP_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (MONOP_EXPR (arg_node), arg_node,
		   "mandatory son MONOP_EXPR is NULL");
      if (MONOP_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (MONOP_EXPR (arg_node)) == N_expr)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "MONOP_EXPR hasnt the right type."
					 " It should be: " "N_expr");
	    }
	}
    }
  else
    {
      CHKnotExist (MONOP_EXPR (arg_node), arg_node,
		   "attribute MONOP_EXPR must be NULL");
    }

/*
 * Attribute check: MONOP_OP
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (MONOP_OP (arg_node), arg_node,
			 "mandatory attribute MONOP_OP is NULL");
    }
  else
    {
      CHKnotExist (MONOP_OP (arg_node), arg_node,
		   "attribute MONOP_OP must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (MONOP_EXPR (arg_node) != NULL)
    {
      MONOP_EXPR (arg_node) = TRAVdo (MONOP_EXPR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKnum
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Num node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKnum (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKnum");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKparam
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Param node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKparam (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKparam");

/*
 * Son check: PARAM_ID 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (PARAM_ID (arg_node), arg_node,
		   "mandatory son PARAM_ID is NULL");
      if (PARAM_ID (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (PARAM_ID (arg_node)) == N_id)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PARAM_ID hasnt the right type."
					 " It should be: " "N_id");
	    }
	}
    }
  else
    {
      CHKnotExist (PARAM_ID (arg_node), arg_node,
		   "attribute PARAM_ID must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (PARAM_ID (arg_node) != NULL)
    {
      PARAM_ID (arg_node) = TRAVdo (PARAM_ID (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKparams
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Params node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKparams (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKparams");

/*
 * Son check: PARAMS_FIRST 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (PARAMS_FIRST (arg_node), arg_node,
		   "mandatory son PARAMS_FIRST is NULL");
      if (PARAMS_FIRST (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (PARAMS_FIRST (arg_node)) == N_param)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PARAMS_FIRST hasnt the right type."
					 " It should be: " "N_param");
	    }
	}
    }
  else
    {
      CHKnotExist (PARAMS_FIRST (arg_node), arg_node,
		   "attribute PARAMS_FIRST must be NULL");
    }

/*
 * Son check: PARAMS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (PARAMS_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (PARAMS_NEXT (arg_node)) == N_params)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PARAMS_NEXT hasnt the right type."
					 " It should be: " "N_params");
	    }
	}
    }
  else
    {
      CHKnotExist (PARAMS_NEXT (arg_node), arg_node,
		   "attribute PARAMS_NEXT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (PARAMS_FIRST (arg_node) != NULL)
    {
      PARAMS_FIRST (arg_node) = TRAVdo (PARAMS_FIRST (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (PARAMS_NEXT (arg_node) != NULL)
    {
      PARAMS_NEXT (arg_node) = TRAVdo (PARAMS_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKreturn
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Return node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKreturn (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKreturn");

/*
 * Son check: RETURN_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      if (RETURN_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (RETURN_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "RETURN_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (RETURN_EXPR (arg_node), arg_node,
		   "attribute RETURN_EXPR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (RETURN_EXPR (arg_node) != NULL)
    {
      RETURN_EXPR (arg_node) = TRAVdo (RETURN_EXPR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKstmts
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Stmts node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKstmts (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKstmts");

/*
 * Son check: STMTS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (STMTS_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (STMTS_NEXT (arg_node)) == N_stmts)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "STMTS_NEXT hasnt the right type."
					 " It should be: " "N_stmts");
	    }
	}
    }
  else
    {
      CHKnotExist (STMTS_NEXT (arg_node), arg_node,
		   "attribute STMTS_NEXT must be NULL");
    }

/*
 * Son check: STMTS_STMT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (STMTS_STMT (arg_node), arg_node,
		   "mandatory son STMTS_STMT is NULL");
      if (STMTS_STMT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isStmt (STMTS_STMT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "STMTS_STMT hasnt the right type."
					 " It should be: " "Nodeset: Stmt");
	    }
	}
    }
  else
    {
      CHKnotExist (STMTS_STMT (arg_node), arg_node,
		   "attribute STMTS_STMT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (STMTS_NEXT (arg_node) != NULL)
    {
      STMTS_NEXT (arg_node) = TRAVdo (STMTS_NEXT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (STMTS_STMT (arg_node) != NULL)
    {
      STMTS_STMT (arg_node) = TRAVdo (STMTS_STMT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKvardec
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node VarDec node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKvardec (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKvardec");

/*
 * Son check: VARDEC_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      if (VARDEC_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (VARDEC_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "VARDEC_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (VARDEC_EXPR (arg_node), arg_node,
		   "attribute VARDEC_EXPR must be NULL");
    }

/*
 * Son check: VARDEC_ID 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (VARDEC_ID (arg_node), arg_node,
		   "mandatory son VARDEC_ID is NULL");
      if (VARDEC_ID (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (VARDEC_ID (arg_node)) == N_id)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "VARDEC_ID hasnt the right type."
					 " It should be: " "N_id");
	    }
	}
    }
  else
    {
      CHKnotExist (VARDEC_ID (arg_node), arg_node,
		   "attribute VARDEC_ID must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (VARDEC_EXPR (arg_node) != NULL)
    {
      VARDEC_EXPR (arg_node) = TRAVdo (VARDEC_EXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (VARDEC_ID (arg_node) != NULL)
    {
      VARDEC_ID (arg_node) = TRAVdo (VARDEC_ID (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKvardecs
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node VarDecs node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKvardecs (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKvardecs");

/*
 * Son check: VARDECS_FIRST 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (VARDECS_FIRST (arg_node), arg_node,
		   "mandatory son VARDECS_FIRST is NULL");
      if (VARDECS_FIRST (arg_node) != NULL)
	{
	  if (!
	      ((FALSE) || (NODE_TYPE (VARDECS_FIRST (arg_node)) == N_vardec)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "VARDECS_FIRST hasnt the right type."
					 " It should be: " "N_vardec");
	    }
	}
    }
  else
    {
      CHKnotExist (VARDECS_FIRST (arg_node), arg_node,
		   "attribute VARDECS_FIRST must be NULL");
    }

/*
 * Son check: VARDECS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (VARDECS_NEXT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE) || (NODE_TYPE (VARDECS_NEXT (arg_node)) == N_vardecs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "VARDECS_NEXT hasnt the right type."
					 " It should be: " "N_vardecs");
	    }
	}
    }
  else
    {
      CHKnotExist (VARDECS_NEXT (arg_node), arg_node,
		   "attribute VARDECS_NEXT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (VARDECS_FIRST (arg_node) != NULL)
    {
      VARDECS_FIRST (arg_node) = TRAVdo (VARDECS_FIRST (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (VARDECS_NEXT (arg_node) != NULL)
    {
      VARDECS_NEXT (arg_node) = TRAVdo (VARDECS_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKwhile
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node While node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKwhile (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKwhile");

/*
 * Son check: WHILE_BLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (WHILE_BLOCK (arg_node), arg_node,
		   "mandatory son WHILE_BLOCK is NULL");
      if (WHILE_BLOCK (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (WHILE_BLOCK (arg_node)) == N_stmts)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "WHILE_BLOCK hasnt the right type."
					 " It should be: " "N_stmts");
	    }
	}
    }
  else
    {
      CHKnotExist (WHILE_BLOCK (arg_node), arg_node,
		   "attribute WHILE_BLOCK must be NULL");
    }

/*
 * Son check: WHILE_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (WHILE_EXPR (arg_node), arg_node,
		   "mandatory son WHILE_EXPR is NULL");
      if (WHILE_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (WHILE_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "WHILE_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (WHILE_EXPR (arg_node), arg_node,
		   "attribute WHILE_EXPR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (WHILE_BLOCK (arg_node) != NULL)
    {
      WHILE_BLOCK (arg_node) = TRAVdo (WHILE_BLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (WHILE_EXPR (arg_node) != NULL)
    {
      WHILE_EXPR (arg_node) = TRAVdo (WHILE_EXPR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

typedef enum
{ CHK_binop_op,
  CHK_bool_value,
  CHK_cast_casttype,
  CHK_error_message,
  CHK_float_value,
  CHK_fundef_export,
  CHK_funheader_rettype,
  CHK_globaldec_type,
  CHK_globaldef_type,
  CHK_id_name,
  CHK_monop_op,
  CHK_num_value,
  CHK_param_type,
  CHK_vardec_type,
} attr_list;
